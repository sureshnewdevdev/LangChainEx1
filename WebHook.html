<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced API Integration Patterns</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        h3 {
            color: #2980b9;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        .diagram {
            font-family: monospace;
            background: #ecf0f1;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 15px 0;
        }
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', monospace;
        }
        .section {
            margin-bottom: 40px;
        }
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .pros, .cons {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
        }
        .pros h4, .cons h4 {
            margin-top: 0;
            color: #27ae60;
        }
        .cons h4 {
            color: #e74c3c;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Advanced API Integration Patterns</h1>
        
        <div class="section">
            <h2>1. Webhooks vs. Polling</h2>
            
            <p>Understanding the difference between polling and webhooks is crucial for efficient API integrations. These patterns address how your application receives updates from external services. Polling is a pull-based mechanism, while webhooks are push-based. Choosing the right one depends on factors like real-time requirements, resource efficiency, and the provider's capabilities.</p>
            
            <h3>Polling: Detailed Explanation</h3>
            <p><strong>Polling</strong> involves your service periodically querying the provider's API to check for updates (e.g., "Any new data?"). This is a traditional, straightforward approach often used in legacy systems or when webhooks aren't available.</p>
            
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros</h4>
                    <ul>
                        <li>Simple to implement—no need for public endpoints.</li>
                        <li>Works even if the provider doesn't support webhooks.</li>
                        <li>Full control over query frequency and data retrieval.</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons</h4>
                    <ul>
                        <li>Inefficient: Leads to unnecessary requests, wasting bandwidth and API quotas.</li>
                        <li>Increased latency: Updates are only detected on the next poll cycle (e.g., every 5 minutes).</li>
                        <li>Scalability issues: High volume of requests can overload your server or hit rate limits.</li>
                        <li>Misses real-time events if polling interval is too long.</li>
                    </ul>
                </div>
            </div>
            
            <h3>Webhooks: Detailed Explanation</h3>
            <p><strong>Webhooks</strong> allow the provider to proactively push notifications to your specified endpoint (URL) when an event occurs. This is event-driven, enabling near real-time updates and is ideal for scenarios like payment confirmations or user notifications.</p>
            
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros</h4>
                    <ul>
                        <li>Real-time: Immediate notifications reduce latency.</li>
                        <li>Efficient: No polling overhead; only triggered on events.</li>
                        <li>Scalable: Handles high event volumes without constant querying.</li>
                        <li>Resource-saving: Lowers server load and API costs.</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons</h4>
                    <ul>
                        <li>Requires a public, secure endpoint (e.g., using ngrok for dev).</li>
                        <li>Handling failures: Providers may retry deliveries, leading to duplicates.</li>
                        <li>Security risks: Validate payloads to prevent spoofing.</li>
                        <li>Not all providers support it; fallback to polling may be needed.</li>
                    </ul>
                </div>
            </div>
            
            <div class="diagram">
                <p><strong>Polling Flow:</strong></p>
                <pre>Your Client ───► Payment Provider (repeated GET requests)
                │
                └─ "Any updates?" ───► Check every X seconds (e.g., cron job)</pre>
                
                <p><strong>Webhook Flow:</strong></p>
                <pre>Client ───► Payment Provider (initial setup: register webhook URL)
                           │
                           └─ Event Triggered (e.g., payment success) ─── HTTP POST ───► https://your-api.com/webhook/payment
                              │
                              └─ Payload: { "event": "payment.succeeded", "data": {...} }</pre>
            </div>
            
            <h3>Webhook Implementation Example (FastAPI)</h3>
            <p>Here's a simple FastAPI endpoint to handle incoming webhook payloads from a payment provider. Ensure your server is publicly accessible and secured (e.g., with signatures for verification). In production, process events asynchronously to avoid timeouts.</p>
            <pre><code>from fastapi import FastAPI, Request, HTTPException
from typing import Dict, Any

app = FastAPI()

@app.post("/webhook/payment")
async def payment_webhook(request: Request):
    payload = await request.json()
    event_type = payload.get("event")
    
    if not event_type:
        raise HTTPException(status_code=400, detail="Missing event type")
    
    print(f"Received event: {event_type}")
    # Verify signature if provided (e.g., Stripe: check X-Signature header)
    # Process the event (e.g., update database, notify users)
    # Example: if event_type == "payment.succeeded": update_order_status(payload["data"]["id"])
    
    return {"status": "ok"}</code></pre>
            
            <p><em>Best Practices:</em></p>
            <ol>
                <li>Validate payloads with HMAC signatures or provider-specific headers to ensure authenticity.</li>
                <li>Handle retries: Use idempotency keys to avoid duplicate processing.</li>
                <li>Use queues (e.g., Celery, Redis) for async processing to handle bursts.</li>
                <li>Respond quickly (under 10s) with 200 OK to acknowledge receipt.</li>
                <li>Monitor failures: Log and alert on repeated delivery attempts.</li>
            </ol>
            
            <p><em>When to Choose:</em> Use webhooks for real-time needs (e.g., notifications); polling for batch processing or unreliable push support.</p>
        </div>
        
        <div class="section">
            <h2>2. Circuit Breaker Pattern</h2>
            
            <p>The Circuit Breaker pattern is a resilience design that prevents cascading failures in distributed systems by monitoring calls to external APIs or services. Inspired by electrical circuit breakers, it "trips" (opens) after detecting repeated failures, stopping further calls to allow the remote service time to recover. This promotes fault tolerance and graceful degradation.</p>
            
            <p>Key States:</p>
            <ul>
                <li><strong>Closed</strong>: Normal operation; calls proceed, failures are counted.</li>
                <li><strong>Open</strong>: Calls are blocked; immediate failures returned (fail-fast).</li>
                <li><strong>Half-Open</strong>: After a timeout, a test call is allowed to check recovery; closes on success, reopens on failure.</li>
            </ul>
            
            <p>This pattern is essential in microservices where one failing dependency can propagate issues. It complements retries and timeouts but focuses on preventing overload.</p>
            
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros</h4>
                    <ul>
                        <li>Prevents cascading failures: Isolates issues quickly.</li>
                        <li>Improves user experience: Fail-fast with cached/fallback data.</li>
                        <li>Self-healing: Automatically recovers when the service stabilizes.</li>
                        <li>Reduces load: Avoids hammering a failing service.</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons</h4>
                    <li>Added complexity: Requires state management and tuning thresholds.</li>
                    <li>False positives: May open too soon on transient issues.</li>
                    <li>Stale data: During open state, users see outdated info.</li>
                    <li>Needs monitoring: Tune based on service SLAs.</li>
                </div>
            </div>
            
            <h3>Simple Python Example</h3>
            <p>This basic implementation tracks failures and toggles the circuit state. It lacks the half-open state for simplicity. In production, use libraries like <code>pybreaker</code> or integrate with <code>resilience4j</code> (Java) for advanced features like timeouts and metrics.</p>
            <pre><code>import requests
import time

FAILURES = 0
OPEN = False
FAILURE_THRESHOLD = 3
TIMEOUT = 60  # Seconds before attempting recovery

def call_partner_api():
    global FAILURES, OPEN

    if OPEN:
        # In production, check if timeout has passed for half-open
        if time.time() - globals().get('OPEN_TIME', 0) > TIMEOUT:
            OPEN = False  # Attempt recovery
            print("Circuit half-open: Testing recovery...")
        else:
            raise RuntimeError("Circuit open - external API is down. Try again later.")

    try:
        resp = requests.get("https://partner.com/api", timeout=5)
        resp.raise_for_status()
        FAILURES = 0  # Reset on success
        OPEN = False
        return resp.json()
    except requests.exceptions.RequestException as e:
        FAILURES += 1
        if FAILURES >= FAILURE_THRESHOLD:
            OPEN = True
            globals()['OPEN_TIME'] = time.time()  # Record open time
            print(f"Circuit opened after {FAILURE_THRESHOLD} failures")
        raise</code></pre>
            
            <h3>Advanced Considerations</h3>
            <table>
                <thead>
                    <tr>
                        <th>Parameter</th>
                        <th>Description</th>
                        <th>Example Value</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Failure Threshold</td>
                        <td>Consecutive errors before opening</td>
                        <td>3-5 (tune per service)</td>
                    </tr>
                    <tr>
                        <td>Timeout Duration</td>
                        <td>Time circuit stays open</td>
                        <td>30-120 seconds</td>
                    </tr>
                    <tr>
                        <td>Success Threshold</td>
                        <td>Consecutive successes to close (half-open)</td>
                        <td>1-3</td>
                    </tr>
                    <tr>
                        <td>Allowed Exceptions</td>
                        <td>Define what counts as failure (e.g., 5xx, timeouts)</td>
                        <td>HTTP 500+, ConnectionError</td>
                    </tr>
                </tbody>
            </table>
            
            <p><em>Enhancements:</em></p>
            <ol>
                <li>Implement half-open state: Allow limited calls after timeout to test recovery.</li>
                <li>Integrate metrics: Use Prometheus or logging to track state changes.</li>
                <li>Combine patterns: Pair with retries (e.g., exponential backoff) and fallbacks (e.g., cached data).</li>
                <li>Distributed: In clusters, use shared state (e.g., Redis) for consistency.</li>
            </ol>
            
            <p><em>Real-World Use:</em> Common in e-commerce (e.g., failing inventory API) or fintech (payment gateways). Libraries like Hystrix (Netflix) popularized it.</p>
        </div>
        
        <footer style="margin-top: 40px; text-align: center; color: #7f8c8d; font-size: 0.9em;">
            <p>Enhanced Notes on API Integration Patterns with Detailed Explanations | Generated on November 28, 2025</p>
        </footer>
    </div>
</body>
</html>